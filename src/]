import numpy as np
import pandas as pd
import pickle
import sys
from multiprocessing import Pool
import cProfile
from scipy.stats import pearsonr
sys.path.append('../cross_validation/')
sys.path.append('../data_procession/')
sys.path.append('../math_functions/')
import sim_func
import cross_validation
import preprocessing

#PATH_TO_DATA='../../data_movilens/test.csv'
PATH_TO_DATA='../../data_movilens/ml-latest-small/ratings.csv'
 
def get_ratings(rating_matrix,intersections,index_active_user):
    users_ratings= []
    for intersection in intersections:
        ratings_neighbour=[]
        ratings_active_user=[]
        for column in intersection[0]:
            #print("column-main-user:{} row_m_u:{} raiting_m_u:{} column_u:{} row_u:{} rating_u:{}"
            #.format(column-1,index_main_user,rating_matrix.iloc[index_main_user,column-1],column-1,row,rating_matrix.iloc[row,column-1]))
            ratings_neighbour.append(rating_matrix.iloc[intersection[1],column])
            ratings_active_user.append(rating_matrix.iloc[index_active_user,column])
        
        users_ratings.append((ratings_neighbour,ratings_active_user,intersection[1]))
    return users_ratings        

def get_intersection(vectors, active_user_index):
    intersections = []
    for i,user_rating_indexes in enumerate(vectors):
    #    print(f"loop row_index:{i}, missing_index:{missing_rating_index},active_user_index:{active_user_index},user_index{user_index}") 
            intersection =(np.intersect1d(np.array(vectors[active_user_index[0]]),np.array(user_rating_indexes)),i)
            #intersections.append((list(set(user_index).intersection(set(vectors[active_user_index]))),i))
            if len(intersection[0])>1:
                intersections.append(intersection)
    return intersections 

def get_indexes_of_missing_ratings(user_id,rating_matrix):
    missing_indexes=[]
    for column in range(len(rating_matrix.columns)):
        cell_value = rating_matrix.iloc[user_id,column]
        if np.isnan(cell_value.values[0]):
           missing_indexes.append((column,user_id))
    return missing_indexes


def get_indexes_of_not_empty_columns(rating_matrix):
    not_emnpty_column_vectors = []
    for row in range(len(rating_matrix)): 
        not_empty_indexes=[] 
        for column,_ in enumerate(rating_matrix.columns):
            cell_value=rating_matrix.iloc[row,column]
            if not np.isnan(cell_value):
                not_empty_indexes.append(column) 
        not_emnpty_column_vectors.append(not_empty_indexes)
    return not_emnpty_column_vectors    

def get_top_k_users(similarities,size,missing_rating_index,column_vectors):
    ret = []
    sorted_list = sorted(similarities, key=lambda x: x[0],reverse=True)
    if size > len(sorted_list):
        return [] 
    for similarity in sorted_list: 
        if len(ret)>size:
         return ret
        if missing_rating_index[0] in column_vectors[similarity[1]]:
            ret.append((similarity[0],similarity[1]))
    return ret

def predict_ratings_for_user(user_args):
    user=user_args[0]
    column_vectors=user_args[1]
    rating_matrix=user_args[2]
    top_k_users_size= 5
    similarities = []
    predictions=[]
    users_mean= rating_matrix.mean(1)
    #    print(f"user_index:{user}")
    missing_ratings_indexes=get_indexes_of_missing_ratings(user,rating_matrix)
        #print(f"missing_ratings:{missing_ratings_indexes}")
    all_user_intersections = get_intersection(column_vectors,user)
    intersection_rating = get_ratings(rating_matrix,all_user_intersections,user)
    for index,rating in enumerate(intersection_rating):
        similarities.append((sim_func.raw_cosine(rating[0],rating[1]),rating[2]))

    #print(similarities)
    for missing_rating_index in missing_ratings_indexes:
        numerator = 0
        sim = 0 
        top_k_users=get_top_k_users(similarities,top_k_users_size,missing_rating_index,column_vectors)
        if len(top_k_users)==0:
            continue
        for similarity in top_k_users:
                 #print(f"similarity:{similarity},missing_rating_index:{missing_rating_index},rating:{rating_matrix.iloc[similarity[1], missing_rating_index[0]]}")
                 numerator+=similarity[0]*(rating_matrix.iloc[similarity[1], missing_rating_index[0]]-users_mean.iloc[missing_rating_index[1]].values[0])
                 sim+=similarity[0]
        prediction = (user,missing_rating_index[0],users_mean.iloc[user].values[0]+(numerator/sim))
        print(f"predictions:{prediction}")
        predictions.append(prediction)

    return predictions 
    

if __name__ == '__main__':
    dataframe=pd.read_csv(PATH_TO_DATA,delimiter=',')
    rating_matrix= pd.pivot_table(data=dataframe,index="userId",columns="movieId", values="rating")
    print(rating_matrix)
    users_indexes=[0]
    column_vectors=0
    users_mean= rating_matrix.mean(1)
    result = cross_validation.create_parts_dataset(5,131,rating_matrix,0)
    #column_vectors = cross_validation.get_indexes_of_not_empty_ratings(result[1])
    with open('column_vectors_form_updated_matrix.pickle', 'rb') as file:
        column_vectors=pickle.load(file)
    predictions = []
    updated_rating_matrix = result[1]
    user_args=(users_indexes,column_vectors,updated_rating_matrix) 
     # Create a cProfile object
    profiler = cProfile.Profile()
    predict_ratings_for_user(user_args)
    profiler.disable()
    profiler.print_stats()

